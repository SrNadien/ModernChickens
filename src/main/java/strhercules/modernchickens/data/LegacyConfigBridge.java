package strhercules.modernchickens.data;

import strhercules.modernchickens.ChickensRegistryItem;
import strhercules.modernchickens.config.ChickensConfigValues;
import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.ItemStack;
import net.neoforged.fml.loading.FMLPaths;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Comparator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.TreeMap;

/**
 * Bridges the legacy Forge {@code chickens.cfg} format so existing installations
 * can keep using the configuration layout they are familiar with. The bridge
 * imports key values into the properties-driven system and re-exports an updated
 * cfg file after bootstrap.
 */
public final class LegacyConfigBridge {
    private static final Logger LOGGER = LoggerFactory.getLogger("ChickensLegacyConfig");

    private LegacyConfigBridge() {
    }

    public static void importIfPresent(Properties props, List<ChickensRegistryItem> chickens) {
        Path legacyPath = legacyConfigPath();
        if (!Files.exists(legacyPath)) {
            return;
        }
        Map<String, ChickensRegistryItem> byName = mapByName(chickens);
        try (BufferedReader reader = Files.newBufferedReader(legacyPath, StandardCharsets.UTF_8)) {
            String currentSection = null;
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty() || line.startsWith("#")) {
                    continue;
                }
                if (line.endsWith("{")) {
                    currentSection = line.substring(0, line.length() - 1).trim();
                    continue;
                }
                if (line.equals("}")) {
                    currentSection = null;
                    continue;
                }
                int eq = line.indexOf('=');
                if (eq <= 0) {
                    continue;
                }
                String key = line.substring(0, eq).trim();
                String value = line.substring(eq + 1).trim();
                int colon = key.indexOf(':');
                if (colon >= 0) {
                    key = key.substring(colon + 1);
                }
                if (currentSection == null) {
                    continue;
                }
                if ("general".equalsIgnoreCase(currentSection)) {
                    applyGeneralValue(props, key, value);
                } else {
                    ChickensRegistryItem chicken = byName.get(currentSection);
                    if (chicken != null) {
                        applyChickenValue(props, chicken, key, value);
                    }
                }
            }
        } catch (IOException ex) {
            LOGGER.warn("Failed to read legacy chickens.cfg", ex);
        }
    }

    public static void export(Properties props, List<ChickensRegistryItem> chickens, ChickensConfigValues general) {
        Path legacyPath = legacyConfigPath();
        try {
            Files.createDirectories(legacyPath.getParent());
        } catch (IOException ex) {
            LOGGER.warn("Unable to create configuration directory for legacy cfg export", ex);
            return;
        }

        List<ChickensRegistryItem> ordered = chickens.stream()
                .sorted(Comparator.comparingInt(ChickensRegistryItem::getId))
                .toList();

        try (BufferedWriter writer = Files.newBufferedWriter(legacyPath, StandardCharsets.UTF_8)) {
            writer.write("# Auto-generated by Modern Chickens to maintain legacy configuration compatibility.\n");
            writer.write("# Editing this file will update the modern configuration on next launch.\n\n");

            writer.write("general {\n");
            writer.write(String.format(Locale.ROOT, "    I:spawnProbability=%d%n", general.getSpawnProbability()));
            writer.write(String.format(Locale.ROOT, "    I:minBroodSize=%d%n", general.getMinBroodSize()));
            writer.write(String.format(Locale.ROOT, "    I:maxBroodSize=%d%n", general.getMaxBroodSize()));
            writer.write(String.format(Locale.ROOT, "    D:netherSpawnChanceMultiplier=%.3f%n", general.getNetherSpawnChanceMultiplier()));
            writer.write(String.format(Locale.ROOT, "    D:overworldSpawnChance=%.5f%n", general.getOverworldSpawnChance()));
            writer.write(String.format(Locale.ROOT, "    D:netherSpawnChance=%.5f%n", general.getNetherSpawnChance()));
            writer.write(String.format(Locale.ROOT, "    D:endSpawnChance=%.5f%n", general.getEndSpawnChance()));
            writer.write(String.format(Locale.ROOT, "    B:alwaysShowStats=%s%n", general.isAlwaysShowStats()));
            writer.write(String.format(Locale.ROOT, "    D:roostSpeed=%.3f%n", general.getRoostSpeedMultiplier()));
            writer.write(String.format(Locale.ROOT, "    D:breederSpeed=%.3f%n", general.getBreederSpeedMultiplier()));
            writer.write(String.format(Locale.ROOT, "    D:roosterAuraMultiplier=%.3f%n", general.getRoosterAuraMultiplier()));
            writer.write(String.format(Locale.ROOT, "    I:roosterAuraRange=%d%n", general.getRoosterAuraRange()));
            writer.write(String.format(Locale.ROOT, "    I:nestMaxRoosters=%d%n", general.getNestMaxRoosters()));
            writer.write(String.format(Locale.ROOT, "    I:nestSeedDurationTicks=%d%n", general.getNestSeedDurationTicks()));
            writer.write(String.format(Locale.ROOT, "    B:disableEggLaying=%s%n", general.isVanillaEggLayingDisabled()));
            writer.write(String.format(Locale.ROOT, "    I:collectorScanRange=%d%n", general.getCollectorScanRange()));
            writer.write(String.format(Locale.ROOT, "    B:avianFluxEffectsEnabled=%s%n", general.isAvianFluxEffectsEnabled()));
            writer.write(String.format(Locale.ROOT, "    D:fluxEggCapacityMultiplier=%.3f%n", general.getFluxEggCapacityMultiplier()));
            writer.write(String.format(Locale.ROOT, "    I:avianFluxCapacity=%d%n", general.getAvianFluxCapacity()));
            writer.write(String.format(Locale.ROOT, "    I:avianFluxMaxReceive=%d%n", general.getAvianFluxMaxReceive()));
            writer.write(String.format(Locale.ROOT, "    I:avianFluxMaxExtract=%d%n", general.getAvianFluxMaxExtract()));
            // Keep converter and hazard settings in cfg so KubeJS handles only chicken-specific data.
            writer.write(String.format(Locale.ROOT, "    I:avianFluidConverterCapacity=%d%n", general.getAvianFluidConverterCapacity(0)));
            writer.write(String.format(Locale.ROOT, "    I:avianFluidConverterTransferRate=%d%n", general.getAvianFluidConverterTransfer(0)));
            writer.write(String.format(Locale.ROOT, "    B:avianFluidConverterEffectsEnabled=%s%n", general.isAvianFluidConverterEffectsEnabled()));
            writer.write(String.format(Locale.ROOT, "    I:avianChemicalConverterCapacity=%d%n", general.getAvianChemicalConverterCapacity(0)));
            writer.write(String.format(Locale.ROOT, "    I:avianChemicalConverterTransferRate=%d%n", general.getAvianChemicalConverterTransfer(0)));
            writer.write(String.format(Locale.ROOT, "    B:avianChemicalConverterEffectsEnabled=%s%n", general.isAvianChemicalConverterEffectsEnabled()));
            writer.write(String.format(Locale.ROOT, "    B:liquidEggHazardsEnabled=%s%n", general.isLiquidEggHazardsEnabled()));
            writer.write(String.format(Locale.ROOT, "    I:incubatorEnergyCost=%d%n", general.getIncubatorEnergyCost()));
            writer.write(String.format(Locale.ROOT, "    I:incubatorCapacity=%d%n", general.getIncubatorEnergyCapacity()));
            writer.write(String.format(Locale.ROOT, "    I:incubatorMaxReceive=%d%n", general.getIncubatorEnergyMaxReceive()));
            writer.write(String.format(Locale.ROOT, "    B:enableFluidChickens=%s%n", general.isFluidChickensEnabled()));
            writer.write(String.format(Locale.ROOT, "    B:enableChemicalChickens=%s%n", general.isChemicalChickensEnabled()));
            writer.write(String.format(Locale.ROOT, "    B:enableGasChickens=%s%n", general.isGasChickensEnabled()));
            writer.write("}\n\n");

            for (ChickensRegistryItem chicken : ordered) {
                String category = chicken.getEntityName();
                writer.write(category + " {\n");
                String prefix = prefixFor(category);
                writer.write(String.format(Locale.ROOT, "    B:enabled=%s%n", getBoolean(props, prefix + "enabled", true)));
                writer.write(String.format(Locale.ROOT, "    D:layCoefficient=%s%n", getString(props, prefix + "layCoefficient", "1.0")));
                writer.write(String.format(Locale.ROOT, "    S:spawnType=%s%n", getString(props, prefix + "spawnType", chicken.getSpawnType().name())));
            writer.write(String.format(Locale.ROOT, "    B:allowNaturalSpawn=%s%n", getBoolean(props, prefix + "allowNaturalSpawn", chicken.hasNaturalSpawnOverride())));
            writer.write(String.format(Locale.ROOT, "    S:parent1=%s%n", getString(props, prefix + "parent1", chicken.getParent1() != null ? chicken.getParent1().getEntityName() : "")));
            writer.write(String.format(Locale.ROOT, "    S:parent2=%s%n", getString(props, prefix + "parent2", chicken.getParent2() != null ? chicken.getParent2().getEntityName() : "")));
            writer.write(String.format(Locale.ROOT, "    I:liquidDousingCost=%d%n", getInt(props, prefix + "liquidDousingCost", chicken.getLiquidDousingCost())));

            writeItemEntry(writer, props, prefix, "egg", chicken.createLayItem());
            writeItemEntry(writer, props, prefix, "drop", chicken.createDropItem());

                writer.write("}\n\n");
            }
        } catch (IOException ex) {
            LOGGER.warn("Failed to write legacy chickens.cfg", ex);
        }
    }

    private static void applyGeneralValue(Properties props, String key, String value) {
        switch (key) {
            case "spawnProbability" -> props.setProperty("general.spawnProbability", value);
            case "minBroodSize" -> props.setProperty("general.minBroodSize", value);
            case "maxBroodSize" -> props.setProperty("general.maxBroodSize", value);
            case "netherSpawnChanceMultiplier" -> props.setProperty("general.netherSpawnChanceMultiplier", value);
            case "overworldSpawnChance" -> props.setProperty("general.overworldSpawnChance", value);
            case "netherSpawnChance" -> props.setProperty("general.netherSpawnChance", value);
            case "endSpawnChance" -> props.setProperty("general.endSpawnChance", value);
            case "alwaysShowStats" -> props.setProperty("general.alwaysShowStats", value);
            case "roostSpeed" -> props.setProperty("general.roostSpeedMultiplier", value);
            case "breederSpeed" -> props.setProperty("general.breederSpeedMultiplier", value);
            case "roosterAuraMultiplier" -> props.setProperty("general.roosterAuraMultiplier", value);
            case "roosterAuraRange" -> props.setProperty("general.roosterAuraRange", value);
            case "nestMaxRoosters" -> props.setProperty("general.nestMaxRoosters", value);
            case "nestSeedDurationTicks" -> props.setProperty("general.nestSeedDurationTicks", value);
            case "disableEggLaying" -> props.setProperty("general.disableVanillaEggLaying", value);
            case "collectorScanRange" -> props.setProperty("general.collectorScanRange", value);
            case "avianFluxEffectsEnabled" -> props.setProperty("general.avianFluxEffectsEnabled", value);
            case "fluxEggCapacityMultiplier" -> props.setProperty("general.fluxEggCapacityMultiplier", value);
            case "avianFluxCapacity" -> props.setProperty("general.avianFluxCapacity", value);
            case "avianFluxMaxReceive" -> props.setProperty("general.avianFluxMaxReceive", value);
            case "avianFluxMaxExtract" -> props.setProperty("general.avianFluxMaxExtract", value);
            case "avianFluidConverterCapacity" -> props.setProperty("general.avianFluidConverterCapacity", value);
            case "avianFluidConverterTransferRate" -> props.setProperty("general.avianFluidConverterTransferRate", value);
            case "avianFluidConverterEffectsEnabled" -> props.setProperty("general.avianFluidConverterEffectsEnabled", value);
            case "avianChemicalConverterCapacity" -> props.setProperty("general.avianChemicalConverterCapacity", value);
            case "avianChemicalConverterTransferRate" -> props.setProperty("general.avianChemicalConverterTransferRate", value);
            case "avianChemicalConverterEffectsEnabled" -> props.setProperty("general.avianChemicalConverterEffectsEnabled", value);
            case "liquidEggHazardsEnabled" -> props.setProperty("general.liquidEggHazardsEnabled", value);
            case "incubatorEnergyCost" -> props.setProperty("general.incubatorEnergyCost", value);
            case "incubatorCapacity" -> props.setProperty("general.incubatorCapacity", value);
            case "incubatorMaxReceive" -> props.setProperty("general.incubatorMaxReceive", value);
            case "enableFluidChickens" -> props.setProperty("general.enableFluidChickens", value);
            case "enableChemicalChickens" -> props.setProperty("general.enableChemicalChickens", value);
            case "enableGasChickens" -> props.setProperty("general.enableGasChickens", value);
            default -> {
            }
        }
    }

    private static void applyChickenValue(Properties props, ChickensRegistryItem chicken, String key, String value) {
        String prefix = prefixFor(chicken.getEntityName());
        switch (key) {
            case "enabled" -> props.setProperty(prefix + "enabled", value);
            case "layCoefficient" -> props.setProperty(prefix + "layCoefficient", value);
            case "spawnType" -> props.setProperty(prefix + "spawnType", value);
            case "allowNaturalSpawn" -> props.setProperty(prefix + "allowNaturalSpawn", value);
            case "parent1" -> props.setProperty(prefix + "parent1", value);
            case "parent2" -> props.setProperty(prefix + "parent2", value);
            case "layItemName" -> props.setProperty(prefix + "eggItem", value);
            case "layItemAmount" -> props.setProperty(prefix + "eggCount", value);
            case "layItemMeta" -> props.setProperty(prefix + "eggType", value);
            case "dropItemName" -> props.setProperty(prefix + "dropItem", value);
            case "dropItemAmount" -> props.setProperty(prefix + "dropCount", value);
            case "dropItemMeta" -> props.setProperty(prefix + "dropType", value);
            case "liquidDousingCost" -> props.setProperty(prefix + "liquidDousingCost", value);
            default -> {
            }
        }
    }

    private static void writeItemEntry(BufferedWriter writer, Properties props, String prefix, String kind, ItemStack stack) throws IOException {
        String itemKey = prefix + kind + "Item";
        String countKey = prefix + kind + "Count";
        String metaKey = prefix + kind + "Type";

        String itemId = getString(props, itemKey, getItemId(stack));
        String count = getString(props, countKey, Integer.toString(stack.getCount()));
        String type = getString(props, metaKey, "0");

        String legacyPrefix = "egg".equals(kind) ? "lay" : "drop";
        writer.write(String.format(Locale.ROOT, "    S:%sItemName=%s%n", legacyPrefix, itemId));
        writer.write(String.format(Locale.ROOT, "    I:%sItemAmount=%s%n", legacyPrefix, count));
        writer.write(String.format(Locale.ROOT, "    I:%sItemMeta=%s%n", legacyPrefix, type));
    }

    private static Map<String, ChickensRegistryItem> mapByName(List<ChickensRegistryItem> chickens) {
        Map<String, ChickensRegistryItem> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
        for (ChickensRegistryItem chicken : chickens) {
            result.put(chicken.getEntityName(), chicken);
        }
        return result;
    }

    private static String prefixFor(String entityName) {
        return "chicken." + entityName + ".";
    }

    private static String getString(Properties props, String key, String fallback) {
        return props.getProperty(key, fallback);
    }

    private static String getBoolean(Properties props, String key, boolean fallback) {
        return props.getProperty(key, Boolean.toString(fallback));
    }

    private static int getInt(Properties props, String key, int fallback) {
        String value = props.getProperty(key);
        if (value == null) {
            return fallback;
        }
        try {
            return Integer.parseInt(value.trim());
        } catch (NumberFormatException ex) {
            return fallback;
        }
    }

    private static Path legacyConfigPath() {
        return FMLPaths.CONFIGDIR.get().resolve("chickens.cfg");
    }

    private static String getItemId(ItemStack stack) {
        ResourceLocation id = BuiltInRegistries.ITEM.getKey(stack.getItem());
        return id != null ? id.toString() : "minecraft:air";
    }
}
